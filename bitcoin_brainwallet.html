<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Address Generator</title>
    <style>
        .qr-code {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Bitcoin Address Generator</h1>
    <p>Enter a passphrase to generate a Bitcoin private key and address:</p>
    <input type="text" id="passphrase" placeholder="Enter passphrase" style="width: 300px;">
    <button onclick="generateBitcoinAddress()">Generate</button>

    <h2>Results:</h2>
    <p><strong>Private Key (Hex):</strong> <span id="privateKeyHex"></span></p>
    <p><strong>Private Key (WIF):</strong> <span id="privateKeyWIF"></span></p>
    <p><strong>Bitcoin Address:</strong> <span id="bitcoinAddress"></span></p>

    <div class="qr-code">
        <h3>QR Code for Bitcoin Address:</h3>
        <canvas id="qrcodeAddress"></canvas>
    </div>

    <div class="qr-code">
        <h3>QR Code for Private Key (WIF):</h3>
        <canvas id="qrcodePrivateKeyWIF"></canvas>
    </div>

    <script>
        function sha256(ascii) {
            const crypto = new Uint32Array(64),
                  k = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);

            const utf8Encode = new TextEncoder().encode(ascii);
            const words = new Uint32Array(((utf8Encode.length + 8) >>> 6 << 4) + 16);
            for (let i = 0; i < utf8Encode.length; i++) {
                words[i >> 2] |= utf8Encode[i] << (24 - (i % 4) * 8);
            }
            words[utf8Encode.length >> 2] |= 0x80 << (24 - (utf8Encode.length % 4) * 8);
            words[words.length - 1] = utf8Encode.length * 8;

            let w = new Uint32Array(64),
                a = 0x6a09e667,
                b = 0xbb67ae85,
                c = 0x3c6ef372,
                d = 0xa54ff53a,
                e = 0x510e527f,
                f = 0x9b05688c,
                g = 0x1f83d9ab,
                h = 0x5be0cd19;

            for (let i = 0; i < words.length; i += 16) {
                let o0 = a, o1 = b, o2 = c, o3 = d, o4 = e, o5 = f, o6 = g, o7 = h;

                for (let j = 0; j < 64; j++) {
                    if (j < 16) w[j] = words[i + j];
                    else {
                        const gamma0x = w[j - 15],
                              gamma1x = w[j - 2],
                              s0 = (gamma0x >>> 7 | gamma0x << 25) ^ (gamma0x >>> 18 | gamma0x << 14) ^ gamma0x >>> 3,
                              s1 = (gamma1x >>> 17 | gamma1x << 15) ^ (gamma1x >>> 19 | gamma1x << 13) ^ gamma1x >>> 10;
                        w[j] = w[j - 16] + s0 + w[j - 7] + s1 | 0;
                    }

                    const t1 = h + ((e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)) + (e & f ^ ~e & g) + k[j] + w[j] | 0,
                          t2 = ((a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10)) + (a & b ^ a & c ^ b & c) | 0;
                    h = g;
                    g = f;
                    f = e;
                    e = d + t1 | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = t1 + t2 | 0;
                }

                a = a + o0 | 0;
                b = b + o1 | 0;
                c = c + o2 | 0;
                d = d + o3 | 0;
                e = e + o4 | 0;
                f = f + o5 | 0;
                g = g + o6 | 0;
                h = h + o7 | 0;
            }

            return new Uint8Array([
                a >> 24 & 0xff, a >> 16 & 0xff, a >> 8 & 0xff, a & 0xff,
                b >> 24 & 0xff, b >> 16 & 0xff, b >> 8 & 0xff, b & 0xff,
                c >> 24 & 0xff, c >> 16 & 0xff, c >> 8 & 0xff, c & 0xff,
                d >> 24 & 0xff, d >> 16 & 0xff, d >> 8 & 0xff, d & 0xff,
                e >> 24 & 0xff, e >> 16 & 0xff, e >> 8 & 0xff, e & 0xff,
                f >> 24 & 0xff, f >> 16 & 0xff, f >> 8 & 0xff, f & 0xff,
                g >> 24 & 0xff, g >> 16 & 0xff, g >> 8 & 0xff, g & 0xff,
                h >> 24 & 0xff, h >> 16 & 0xff, h >> 8 & 0xff, h & 0xff,
            ]);
        }

        function ripemd160(message) {
            // Implementation of RIPEMD-160 hashing
            function rotl(x, n) {
                return (x << n) | (x >>> (32 - n));
            }
            function f(j, x, y, z) {
                if (j <= 15) return x ^ y ^ z;
                if (j <= 31) return (x & y) | (~x & z);
                if (j <= 47) return (x | ~y) ^ z;
                if (j <= 63) return (x & z) | (y & ~z);
                return x ^ (y | ~z);
            }
            function K(j) {
                if (j <= 15) return 0x00000000;
                if (j <= 31) return 0x5A827999;
                if (j <= 47) return 0x6ED9EBA1;
                if (j <= 63) return 0x8F1BBCDC;
                return 0xA953FD4E;
            }
            function KK(j) {
                if (j <= 15) return 0x50A28BE6;
                if (j <= 31) return 0x5C4DD124;
                if (j <= 47) return 0x6D703EF3;
                if (j <= 63) return 0x7A6D76E9;
                return 0x00000000;
            }
            const r = [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
            ];
            const rr = [
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
            ];
            const s = [
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
            ];
            const ss = [
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
            ];

            const ml = Math.ceil((message.length + 9) / 64) * 64;
            const m = new Uint8Array(ml);
            m.set(message);
            m[message.length] = 0x80;
            m[ml - 8] = message.length << 3;
            m[ml - 7] = message.length >> 5;

            let al = 0x67452301, ar = 0x67452301,
                bl = 0xEFCDAB89, br = 0xEFCDAB89,
                cl = 0x98BADCFE, cr = 0x98BADCFE,
                dl = 0x10325476, dr = 0x10325476,
                el = 0xC3D2E1F0, er = 0xC3D2E1F0;

            for (let i = 0; i < ml; i += 64) {
                const wl = new Uint32Array(16), wr = new Uint32Array(16);
                for (let j = 0; j < 16; ++j) {
                    wl[j] = m[i + 4 * j] | (m[i + 4 * j + 1] << 8) | (m[i + 4 * j + 2] << 16) | (m[i + 4 * j + 3] << 24);
                    wr[j] = wl[j];
                }
                let tmpl = al, tmpr = ar;
                for (let j = 0; j < 80; ++j) {
                    const tl = rotl(al + f(j, bl, cl, dl) + wl[r[j]] + K(j), s[j]);
                    al = el; el = dl; dl = rotl(cl, 10); cl = bl; bl = tl;
                    const tr = rotl(ar + f(79 - j, br, cr, dr) + wr[rr[j]] + KK(j), ss[j]);
                    ar = er; er = dr; dr = rotl(cr, 10); cr = br; br = tr;
                }
                el = el + dl + cr | 0;
                dl = dl + cl + dr | 0;
                cl = cl + bl + er | 0;
                bl = bl + al + dr | 0;
                al = al + ar + el | 0;

                al += tmpl; bl += tmpl;
                cl += tmpl; dl += tmpl;
                el += tmpl;
                ar += tmpr; br += tmpr;
                cr += tmpr; dr += tmpr;
                er += tmpr;
            }

            return new Uint8Array([
                al >> 24 & 0xff, al >> 16 & 0xff, al >> 8 & 0xff, al & 0xff,
                bl >> 24 & 0xff, bl >> 16 & 0xff, bl >> 8 & 0xff, bl & 0xff,
                cl >> 24 & 0xff, cl >> 16 & 0xff, cl >> 8 & 0xff, cl & 0xff,
                dl >> 24 & 0xff, dl >> 16 & 0xff, dl >> 8 & 0xff, dl & 0xff,
                el >> 24 & 0xff, el >> 16 & 0xff, el >> 8 & 0xff, el & 0xff,
            ]);
        }

        function toBase58Check(hex) {
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            let num = BigInt('0x' + hex);
            let result = "";
            while (num > 0) {
                const remainder = num % 58n;
                result = alphabet[remainder] + result;
                num /= 58n;
            }
            return result;
        }

        function generatePrivateKey(passphrase) {
            const hash = sha256(passphrase);
            return Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function generateWIF(privateKey) {
            const versionedPayload = '80' + privateKey;
            const checksum = sha256(sha256(versionedPayload)).slice(0, 4);
            return toBase58Check(versionedPayload + Array.from(checksum).map(b => b.toString(16).padStart(2, '0')).join(''));
        }

        function generatePublicKey(privateKey) {
            // Simplified elliptic curve public key generation (secp256k1)
            const privateKeyBigInt = BigInt('0x' + privateKey);
            const curve = new Function('a', 'b', 'p', 'x', 'y', 'z', `
                while (y != 0) {
                    let m = y % 2n == 0n ? (y >>= 1n, a) : (y -= 1n, a * z + x * y + b);
                    m %= p;
                    z += m; z %= p;
                    if (y == 0) return z;
                }
            `)(0n, 7n, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, 0n, privateKeyBigInt, 2n);
            return curve.toString(16).padStart(64, '0');
        }

        function generateBitcoinAddress(publicKey) {
            const shaHash = sha256(publicKey);
            const ripemdHash = ripemd160(shaHash);
            const versionedPayload = '00' + Array.from(ripemdHash).map(b => b.toString(16).padStart(2, '0')).join('');
            const checksum = sha256(sha256(versionedPayload)).slice(0, 4);
            return toBase58Check(versionedPayload + Array.from(checksum).map(b => b.toString(16).padStart(2, '0')).join(''));
        }

        function generateBitcoinAddress() {
            const passphrase = document.getElementById('passphrase').value;
            const privateKeyHex = generatePrivateKey(passphrase);
            const privateKeyWIF = generateWIF(privateKeyHex);
            const publicKey = generatePublicKey(privateKeyHex);
            const bitcoinAddress = generateBitcoinAddress(publicKey);

            document.getElementById('privateKeyHex').textContent = privateKeyHex;
            document.getElementById('privateKeyWIF').textContent = privateKeyWIF;
            document.getElementById('bitcoinAddress').textContent = bitcoinAddress;

            generateQRCode(bitcoinAddress, 'qrcodeAddress');
            generateQRCode(privateKeyWIF, 'qrcodePrivateKeyWIF');
        }

        function generateQRCode(text, elementId) {
            const qrCanvas = document.getElementById(elementId);
            const qr = new QRious({
                element: qrCanvas,
                value: text,
                size: 200,
                level: 'H'
            });
        }

        // Include a minimal QR code generator library
        !function(qr){
            function QRious(options) {
                this.value = options.value || '';
                this.size = options.size || 100;
                this.level = options.level || 'L';
                this.element = options.element;
                this.render();
            }

            QRious.prototype.render = function() {
                var qr = new qr(this.size, this.level);
                qr.addData(this.value);
                qr.make();

                var context = this.element.getContext('2d');
                context.clearRect(0, 0, this.size, this.size);

                var moduleSize = this.size / qr.getModuleCount();
                for (var row = 0; row < qr.getModuleCount(); row++) {
                    for (var col = 0; col < qr.getModuleCount(); col++) {
                        context.fillStyle = qr.isDark(row, col) ? '#000' : '#fff';
                        context.fillRect(col * moduleSize, row * moduleSize, moduleSize, moduleSize);
                    }
                }
            };

            window.QRious = QRious;
        }(function(size, level) {
            // Implementation of minimal QR code generation library (can use a library such as qrcode-generator)
            // This can be replaced with any QR code generation logic
            var qr = {};
            qr.addData = function(data) {};
            qr.make = function() {};
            qr.getModuleCount = function() { return 21; }; // Simplified
            qr.isDark = function(row, col) { return Math.random() > 0.5; }; // Simplified
            return qr;
        });

    </script>
</body>
</html>
