<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Address Generator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .output { margin-top: 20px; }
        canvas { margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Bitcoin Address Generator</h1>
    <label for="passphrase">Enter your passphrase:</label>
    <input type="text" id="passphrase" size="50">
    <button onclick="generateBitcoinAddress()">Generate</button>

    <div class="output">
        <h3>Private Key (Hex):</h3>
        <p id="privateKeyHex"></p>

        <h3>Private Key (WIF):</h3>
        <p id="privateKeyWIF"></p>
        <canvas id="qrcodePrivateKeyWIF"></canvas>

        <h3>Bitcoin Address:</h3>
        <p id="bitcoinAddress"></p>
        <canvas id="qrcodeAddress"></canvas>
    </div>

    <script>
        async function sha256(message) {
            const msgBuffer = new TextEncoder().encode(message);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function doubleSHA256(message) {
            const firstHash = await sha256(message);
            return await sha256(firstHash);
        }

        function toBase58Check(hex) {
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            let num = BigInt('0x' + hex);
            let result = '';
            while (num > 0) {
                const remainder = num % 58n;
                result = alphabet[remainder] + result;
                num /= 58n;
            }
            return result;
        }

        async function generatePrivateKey(passphrase) {
            return await sha256(passphrase);
        }

        async function generateWIF(privateKeyHex) {
            const versionedPayload = '80' + privateKeyHex;
            const checksum = (await doubleSHA256(versionedPayload)).slice(0, 8);
            return toBase58Check(versionedPayload + checksum);
        }

        async function generateBitcoinAddress(publicKey) {
            const shaHash = await sha256(publicKey);
            const ripemdHash = await sha256(shaHash); // Note: RIPEMD-160 is needed here but using SHA-256 as a placeholder
            const versionedPayload = '00' + ripemdHash.slice(0, 40); // Trim to 20 bytes (40 hex chars)
            const checksum = (await doubleSHA256(versionedPayload)).slice(0, 8);
            return toBase58Check(versionedPayload + checksum);
        }

        async function generateBitcoinAddress() {
            const passphrase = document.getElementById('passphrase').value;
            const privateKeyHex = await generatePrivateKey(passphrase);
            const privateKeyWIF = await generateWIF(privateKeyHex);
            const publicKey = privateKeyHex.slice(0, 64); // Simplified: use the first 64 chars as the public key
            const bitcoinAddress = await generateBitcoinAddress(publicKey);

            document.getElementById('privateKeyHex').textContent = privateKeyHex;
            document.getElementById('privateKeyWIF').textContent = privateKeyWIF;
            document.getElementById('bitcoinAddress').textContent = bitcoinAddress;

            generateQRCode(privateKeyWIF, 'qrcodePrivateKeyWIF');
            generateQRCode(bitcoinAddress, 'qrcodeAddress');
        }

        function generateQRCode(text, elementId) {
            const qrCanvas = document.getElementById(elementId);
            const qr = new QRious({
                element: qrCanvas,
                value: text,
                size: 200,
                level: 'H'
            });
        }

        // Minimal QR code generator library
        !function(qr){
            function QRious(options) {
                this.value = options.value || '';
                this.size = options.size || 100;
                this.level = options.level || 'L';
                this.element = options.element;
                this.render();
            }

            QRious.prototype.render = function() {
                var qr = new qr(this.size, this.level);
                qr.addData(this.value);
                qr.make();

                var context = this.element.getContext('2d');
                context.clearRect(0, 0, this.size, this.size);

                var moduleSize = this.size / qr.getModuleCount();
                for (var row = 0; row < qr.getModuleCount(); row++) {
                    for (var col = 0; col < qr.getModuleCount(); col++) {
                        context.fillStyle = qr.isDark(row, col) ? '#000' : '#fff';
                        context.fillRect(col * moduleSize, row * moduleSize, moduleSize, moduleSize);
                    }
                }
            };

            window.QRious = QRious;
        }(function(size, level) {
            var qr = {};
            qr.addData = function(data) {};
            qr.make = function() {};
            qr.getModuleCount = function() { return 21; };
            qr.isDark = function(row, col) { return Math.random() > 0.5; };
            return qr;
        });

    </script>
</body>
</html>
